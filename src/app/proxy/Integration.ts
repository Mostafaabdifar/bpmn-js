//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICategoryClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateCategoryCommand | undefined): Observable<CreateCategoryResponse>;
    /**
     * @param categoryId (optional) 
     * @return OK
     */
    getById(categoryId: string | undefined): Observable<CategoryDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<CategoryListDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateCategoryCommand | undefined): Observable<CreateCategoryResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoryClient implements ICategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateCategoryCommand | undefined): Observable<CreateCategoryResponse> {
        let url_ = this.baseUrl + "/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCategoryResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCategoryResponse>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @return OK
     */
    getById(categoryId: string | undefined): Observable<CategoryDto> {
        let url_ = this.baseUrl + "/Category/GetById?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<CategoryListDto> {
        let url_ = this.baseUrl + "/Category/GetList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CategoryListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CategoryListDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CategoryListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CategoryListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateCategoryCommand | undefined): Observable<CreateCategoryResponse> {
        let url_ = this.baseUrl + "/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCategoryResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CreateCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCategoryResponse>(null as any);
    }
}

export interface IChannelClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathApiCallingBased(body: AttachChannelPathApiCallingBasedCommand | undefined): Observable<AttachChannelPathResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathCompleteBased(body: AttachChannelPathCompleteBasedCommand | undefined): Observable<AttachChannelPathResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathConditionBased(body: AttachChannelPathConditionBasedCommand | undefined): Observable<AttachChannelPathResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathMapperBased(body: AttachChannelPathMapperBasedCommand | undefined): Observable<AttachChannelPathResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathStartBased(body: AttachChannelPathStartBasedCommand | undefined): Observable<AttachChannelPathResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateChannelCommand | undefined): Observable<CreateChannelResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: DeleteChannelCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    deletePath(body: DeleteChannelPathCommand | undefined): Observable<void>;
    /**
     * @param id (optional) 
     * @return OK
     */
    getById(id: string | undefined): Observable<ChannelDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<ChannelListDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    setNextChannelPath(body: SetNextChannelPathCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateChannelCommand | undefined): Observable<CreateChannelResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ChannelClient implements IChannelClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathApiCallingBased(body: AttachChannelPathApiCallingBasedCommand | undefined): Observable<AttachChannelPathResponse> {
        let url_ = this.baseUrl + "/Channel/AttachPathApiCallingBased";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachPathApiCallingBased(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachPathApiCallingBased(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachChannelPathResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachChannelPathResponse>;
        }));
    }

    protected processAttachPathApiCallingBased(response: HttpResponseBase): Observable<AttachChannelPathResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachChannelPathResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachChannelPathResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathCompleteBased(body: AttachChannelPathCompleteBasedCommand | undefined): Observable<AttachChannelPathResponse> {
        let url_ = this.baseUrl + "/Channel/AttachPathCompleteBased";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachPathCompleteBased(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachPathCompleteBased(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachChannelPathResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachChannelPathResponse>;
        }));
    }

    protected processAttachPathCompleteBased(response: HttpResponseBase): Observable<AttachChannelPathResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachChannelPathResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachChannelPathResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathConditionBased(body: AttachChannelPathConditionBasedCommand | undefined): Observable<AttachChannelPathResponse> {
        let url_ = this.baseUrl + "/Channel/AttachPathConditionBased";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachPathConditionBased(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachPathConditionBased(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachChannelPathResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachChannelPathResponse>;
        }));
    }

    protected processAttachPathConditionBased(response: HttpResponseBase): Observable<AttachChannelPathResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachChannelPathResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachChannelPathResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathMapperBased(body: AttachChannelPathMapperBasedCommand | undefined): Observable<AttachChannelPathResponse> {
        let url_ = this.baseUrl + "/Channel/AttachPathMapperBased";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachPathMapperBased(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachPathMapperBased(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachChannelPathResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachChannelPathResponse>;
        }));
    }

    protected processAttachPathMapperBased(response: HttpResponseBase): Observable<AttachChannelPathResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachChannelPathResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachChannelPathResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    attachPathStartBased(body: AttachChannelPathStartBasedCommand | undefined): Observable<AttachChannelPathResponse> {
        let url_ = this.baseUrl + "/Channel/AttachPathStartBased";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAttachPathStartBased(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAttachPathStartBased(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AttachChannelPathResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AttachChannelPathResponse>;
        }));
    }

    protected processAttachPathStartBased(response: HttpResponseBase): Observable<AttachChannelPathResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttachChannelPathResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AttachChannelPathResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateChannelCommand | undefined): Observable<CreateChannelResponse> {
        let url_ = this.baseUrl + "/Channel/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateChannelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateChannelResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateChannelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateChannelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateChannelResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    delete(body: DeleteChannelCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Channel/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    deletePath(body: DeleteChannelPathCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Channel/DeletePath";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePath(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePath(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getById(id: string | undefined): Observable<ChannelDto> {
        let url_ = this.baseUrl + "/Channel/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChannelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChannelDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ChannelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChannelDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<ChannelListDto> {
        let url_ = this.baseUrl + "/Channel/GetList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ChannelListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ChannelListDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<ChannelListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChannelListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChannelListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setNextChannelPath(body: SetNextChannelPathCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Channel/SetNextChannelPath";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNextChannelPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNextChannelPath(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetNextChannelPath(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateChannelCommand | undefined): Observable<CreateChannelResponse> {
        let url_ = this.baseUrl + "/Channel/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateChannelResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateChannelResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CreateChannelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateChannelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateChannelResponse>(null as any);
    }
}

export interface ICompanyClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateCompanyCommand | undefined): Observable<CreateCompanyResponse>;
    /**
     * @param companyId (optional) 
     * @return OK
     */
    getById(companyId: string | undefined): Observable<CompanyDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<CompanyListDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateCompanyCommand | undefined): Observable<CreateCompanyResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CompanyClient implements ICompanyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateCompanyCommand | undefined): Observable<CreateCompanyResponse> {
        let url_ = this.baseUrl + "/Company/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCompanyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCompanyResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateCompanyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCompanyResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCompanyResponse>(null as any);
    }

    /**
     * @param companyId (optional) 
     * @return OK
     */
    getById(companyId: string | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/Company/GetById?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<CompanyListDto> {
        let url_ = this.baseUrl + "/Company/GetList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyListDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<CompanyListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateCompanyCommand | undefined): Observable<CreateCompanyResponse> {
        let url_ = this.baseUrl + "/Company/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateCompanyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateCompanyResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CreateCompanyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCompanyResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateCompanyResponse>(null as any);
    }
}

export interface IHubTestClient {
    /**
     * @return OK
     */
    start(): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class HubTestClient implements IHubTestClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    start(): Observable<void> {
        let url_ = this.baseUrl + "/HubTest/Start";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processStart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IIntegrationInformationClient {
    /**
     * @return OK
     */
    geHttpStatusCodeList(): Observable<HttpStatusCodeListDto>;
}

@Injectable({
    providedIn: 'root'
})
export class IntegrationInformationClient implements IIntegrationInformationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    geHttpStatusCodeList(): Observable<HttpStatusCodeListDto> {
        let url_ = this.baseUrl + "/IntegrationInformation/GeHttpStatusCodeList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeHttpStatusCodeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeHttpStatusCodeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HttpStatusCodeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HttpStatusCodeListDto>;
        }));
    }

    protected processGeHttpStatusCodeList(response: HttpResponseBase): Observable<HttpStatusCodeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HttpStatusCodeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HttpStatusCodeListDto>(null as any);
    }
}

export interface IIntegrationPointClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateIntegrationPointCommand | undefined): Observable<CreateIntegrationPointResponse>;
    /**
     * @param integrationPointId (optional) 
     * @return OK
     */
    getById(integrationPointId: string | undefined): Observable<IntegrationPointDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<IntegrationPointListDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateIntegrationPointCommand | undefined): Observable<CreateIntegrationPointResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class IntegrationPointClient implements IIntegrationPointClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateIntegrationPointCommand | undefined): Observable<CreateIntegrationPointResponse> {
        let url_ = this.baseUrl + "/IntegrationPoint/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateIntegrationPointResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateIntegrationPointResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateIntegrationPointResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateIntegrationPointResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateIntegrationPointResponse>(null as any);
    }

    /**
     * @param integrationPointId (optional) 
     * @return OK
     */
    getById(integrationPointId: string | undefined): Observable<IntegrationPointDto> {
        let url_ = this.baseUrl + "/IntegrationPoint/GetById?";
        if (integrationPointId === null)
            throw new Error("The parameter 'integrationPointId' cannot be null.");
        else if (integrationPointId !== undefined)
            url_ += "IntegrationPointId=" + encodeURIComponent("" + integrationPointId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegrationPointDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegrationPointDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<IntegrationPointDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegrationPointDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntegrationPointDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<IntegrationPointListDto> {
        let url_ = this.baseUrl + "/IntegrationPoint/GetList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IntegrationPointListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IntegrationPointListDto>;
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<IntegrationPointListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IntegrationPointListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IntegrationPointListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateIntegrationPointCommand | undefined): Observable<CreateIntegrationPointResponse> {
        let url_ = this.baseUrl + "/IntegrationPoint/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateIntegrationPointResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateIntegrationPointResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CreateIntegrationPointResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateIntegrationPointResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateIntegrationPointResponse>(null as any);
    }
}

export interface IMappingClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    createDataMapping(body: CreateDataMappingCommand | undefined): Observable<CreateDataMappingResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createMessageStaticMapping(body: CreateMessageStaticMappingCommand | undefined): Observable<CreateMessageMappingResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createMessageWithMapping(body: CreateMessageWithMappingCommand | undefined): Observable<CreateMessageMappingResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createMessageWithoutMapping(body: CreateMessageWithoutMappingCommand | undefined): Observable<CreateMessageMappingResponse>;
    /**
     * @param dataMappingId (optional) 
     * @return OK
     */
    getDataMappingById(dataMappingId: string | undefined): Observable<DataMappingFullDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getDataMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<DataMappingListDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageMappingListDto>;
    /**
     * @param messageMappingId (optional) 
     * @return OK
     */
    getMessageStaticMappingById(messageMappingId: string | undefined): Observable<MessageStaticMappingDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageStaticMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageStaticMappingListDto>;
    /**
     * @param messageMappingId (optional) 
     * @return OK
     */
    getMessageWithMappingById(messageMappingId: string | undefined): Observable<MessageWithMappingDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageWithMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageWithMappingListDto>;
    /**
     * @param messageMappingId (optional) 
     * @return OK
     */
    getMessageWithoutMappingById(messageMappingId: string | undefined): Observable<MessageWithoutMappingDto>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageWithoutMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageWithoutMappingListDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateDataMapping(body: UpdateDataMappingCommand | undefined): Observable<CreateDataMappingResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessageStaticMapping(body: UpdateMessageStaticMappingCommand | undefined): Observable<CreateMessageMappingResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessageWithMapping(body: UpdateMessageWithMappingCommand | undefined): Observable<CreateMessageMappingResponse>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessageWithoutMapping(body: UpdateMessageWithoutMappingCommand | undefined): Observable<CreateMessageMappingResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class MappingClient implements IMappingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createDataMapping(body: CreateDataMappingCommand | undefined): Observable<CreateDataMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/CreateDataMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDataMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDataMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateDataMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateDataMappingResponse>;
        }));
    }

    protected processCreateDataMapping(response: HttpResponseBase): Observable<CreateDataMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDataMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDataMappingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMessageStaticMapping(body: CreateMessageStaticMappingCommand | undefined): Observable<CreateMessageMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/CreateMessageStaticMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMessageStaticMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMessageStaticMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMessageMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMessageMappingResponse>;
        }));
    }

    protected processCreateMessageStaticMapping(response: HttpResponseBase): Observable<CreateMessageMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMessageMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateMessageMappingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMessageWithMapping(body: CreateMessageWithMappingCommand | undefined): Observable<CreateMessageMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/CreateMessageWithMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMessageWithMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMessageWithMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMessageMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMessageMappingResponse>;
        }));
    }

    protected processCreateMessageWithMapping(response: HttpResponseBase): Observable<CreateMessageMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMessageMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateMessageMappingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createMessageWithoutMapping(body: CreateMessageWithoutMappingCommand | undefined): Observable<CreateMessageMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/CreateMessageWithoutMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMessageWithoutMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMessageWithoutMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMessageMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMessageMappingResponse>;
        }));
    }

    protected processCreateMessageWithoutMapping(response: HttpResponseBase): Observable<CreateMessageMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMessageMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateMessageMappingResponse>(null as any);
    }

    /**
     * @param dataMappingId (optional) 
     * @return OK
     */
    getDataMappingById(dataMappingId: string | undefined): Observable<DataMappingFullDto> {
        let url_ = this.baseUrl + "/Mapping/GetDataMappingById?";
        if (dataMappingId === null)
            throw new Error("The parameter 'dataMappingId' cannot be null.");
        else if (dataMappingId !== undefined)
            url_ += "DataMappingId=" + encodeURIComponent("" + dataMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataMappingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataMappingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataMappingFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataMappingFullDto>;
        }));
    }

    protected processGetDataMappingById(response: HttpResponseBase): Observable<DataMappingFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataMappingFullDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataMappingFullDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getDataMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<DataMappingListDto> {
        let url_ = this.baseUrl + "/Mapping/GetDataMappingList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DataMappingListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DataMappingListDto>;
        }));
    }

    protected processGetDataMappingList(response: HttpResponseBase): Observable<DataMappingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataMappingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataMappingListDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageMappingListDto> {
        let url_ = this.baseUrl + "/Mapping/GetMessageMappingList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageMappingListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageMappingListDto>;
        }));
    }

    protected processGetMessageMappingList(response: HttpResponseBase): Observable<MessageMappingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageMappingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageMappingListDto>(null as any);
    }

    /**
     * @param messageMappingId (optional) 
     * @return OK
     */
    getMessageStaticMappingById(messageMappingId: string | undefined): Observable<MessageStaticMappingDto> {
        let url_ = this.baseUrl + "/Mapping/GetMessageStaticMappingById?";
        if (messageMappingId === null)
            throw new Error("The parameter 'messageMappingId' cannot be null.");
        else if (messageMappingId !== undefined)
            url_ += "MessageMappingId=" + encodeURIComponent("" + messageMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageStaticMappingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageStaticMappingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageStaticMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageStaticMappingDto>;
        }));
    }

    protected processGetMessageStaticMappingById(response: HttpResponseBase): Observable<MessageStaticMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageStaticMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageStaticMappingDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageStaticMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageStaticMappingListDto> {
        let url_ = this.baseUrl + "/Mapping/GetMessageStaticMappingList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageStaticMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageStaticMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageStaticMappingListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageStaticMappingListDto>;
        }));
    }

    protected processGetMessageStaticMappingList(response: HttpResponseBase): Observable<MessageStaticMappingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageStaticMappingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageStaticMappingListDto>(null as any);
    }

    /**
     * @param messageMappingId (optional) 
     * @return OK
     */
    getMessageWithMappingById(messageMappingId: string | undefined): Observable<MessageWithMappingDto> {
        let url_ = this.baseUrl + "/Mapping/GetMessageWithMappingById?";
        if (messageMappingId === null)
            throw new Error("The parameter 'messageMappingId' cannot be null.");
        else if (messageMappingId !== undefined)
            url_ += "MessageMappingId=" + encodeURIComponent("" + messageMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageWithMappingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageWithMappingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageWithMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageWithMappingDto>;
        }));
    }

    protected processGetMessageWithMappingById(response: HttpResponseBase): Observable<MessageWithMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageWithMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageWithMappingDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageWithMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageWithMappingListDto> {
        let url_ = this.baseUrl + "/Mapping/GetMessageWithMappingList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageWithMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageWithMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageWithMappingListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageWithMappingListDto>;
        }));
    }

    protected processGetMessageWithMappingList(response: HttpResponseBase): Observable<MessageWithMappingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageWithMappingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageWithMappingListDto>(null as any);
    }

    /**
     * @param messageMappingId (optional) 
     * @return OK
     */
    getMessageWithoutMappingById(messageMappingId: string | undefined): Observable<MessageWithoutMappingDto> {
        let url_ = this.baseUrl + "/Mapping/GetMessageWithoutMappingById?";
        if (messageMappingId === null)
            throw new Error("The parameter 'messageMappingId' cannot be null.");
        else if (messageMappingId !== undefined)
            url_ += "MessageMappingId=" + encodeURIComponent("" + messageMappingId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageWithoutMappingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageWithoutMappingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageWithoutMappingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageWithoutMappingDto>;
        }));
    }

    protected processGetMessageWithoutMappingById(response: HttpResponseBase): Observable<MessageWithoutMappingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageWithoutMappingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageWithoutMappingDto>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    getMessageWithoutMappingList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<MessageWithoutMappingListDto> {
        let url_ = this.baseUrl + "/Mapping/GetMessageWithoutMappingList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMessageWithoutMappingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMessageWithoutMappingList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageWithoutMappingListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageWithoutMappingListDto>;
        }));
    }

    protected processGetMessageWithoutMappingList(response: HttpResponseBase): Observable<MessageWithoutMappingListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageWithoutMappingListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MessageWithoutMappingListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateDataMapping(body: UpdateDataMappingCommand | undefined): Observable<CreateDataMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/UpdateDataMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDataMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDataMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateDataMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateDataMappingResponse>;
        }));
    }

    protected processUpdateDataMapping(response: HttpResponseBase): Observable<CreateDataMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateDataMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateDataMappingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessageStaticMapping(body: UpdateMessageStaticMappingCommand | undefined): Observable<CreateMessageMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/UpdateMessageStaticMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMessageStaticMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMessageStaticMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMessageMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMessageMappingResponse>;
        }));
    }

    protected processUpdateMessageStaticMapping(response: HttpResponseBase): Observable<CreateMessageMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMessageMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateMessageMappingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessageWithMapping(body: UpdateMessageWithMappingCommand | undefined): Observable<CreateMessageMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/UpdateMessageWithMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMessageWithMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMessageWithMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMessageMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMessageMappingResponse>;
        }));
    }

    protected processUpdateMessageWithMapping(response: HttpResponseBase): Observable<CreateMessageMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMessageMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateMessageMappingResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMessageWithoutMapping(body: UpdateMessageWithoutMappingCommand | undefined): Observable<CreateMessageMappingResponse> {
        let url_ = this.baseUrl + "/Mapping/UpdateMessageWithoutMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMessageWithoutMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMessageWithoutMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateMessageMappingResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateMessageMappingResponse>;
        }));
    }

    protected processUpdateMessageWithoutMapping(response: HttpResponseBase): Observable<CreateMessageMappingResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMessageMappingResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateMessageMappingResponse>(null as any);
    }
}

export interface IPermissionClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    createRole(body: CreatePermissionRoleCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    disabledRole(body: DisabledPermissionRoleCommand | undefined): Observable<void>;
    /**
     * @return OK
     */
    getPermissions(): Observable<PermissionUnitListDto>;
    /**
     * @return OK
     */
    getRoles(): Observable<PermissionRoleListDto>;
    /**
     * @return OK
     */
    getUserPermissions(): Observable<PermissionKeysDto>;
    /**
     * @return OK
     */
    getVersion(): Observable<PermissionVersionDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    set(body: SetPermissionsCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    setPermissionsToRole(body: SetPermissionsToRoleCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    setUsersToRole(body: SetUsersToRoleCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateRole(body: UpdatePermissionRoleCommand | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class PermissionClient implements IPermissionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createRole(body: CreatePermissionRoleCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Permission/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    disabledRole(body: DisabledPermissionRoleCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Permission/DisabledRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisabledRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisabledRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisabledRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return OK
     */
    getPermissions(): Observable<PermissionUnitListDto> {
        let url_ = this.baseUrl + "/Permission/GetPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionUnitListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionUnitListDto>;
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<PermissionUnitListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionUnitListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionUnitListDto>(null as any);
    }

    /**
     * @return OK
     */
    getRoles(): Observable<PermissionRoleListDto> {
        let url_ = this.baseUrl + "/Permission/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionRoleListDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<PermissionRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionRoleListDto>(null as any);
    }

    /**
     * @return OK
     */
    getUserPermissions(): Observable<PermissionKeysDto> {
        let url_ = this.baseUrl + "/Permission/GetUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionKeysDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionKeysDto>;
        }));
    }

    protected processGetUserPermissions(response: HttpResponseBase): Observable<PermissionKeysDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionKeysDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionKeysDto>(null as any);
    }

    /**
     * @return OK
     */
    getVersion(): Observable<PermissionVersionDto> {
        let url_ = this.baseUrl + "/Permission/GetVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionVersionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionVersionDto>;
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<PermissionVersionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionVersionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionVersionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    set(body: SetPermissionsCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Permission/Set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setPermissionsToRole(body: SetPermissionsToRoleCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Permission/SetPermissionsToRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPermissionsToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPermissionsToRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPermissionsToRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    setUsersToRole(body: SetUsersToRoleCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Permission/SetUsersToRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetUsersToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetUsersToRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetUsersToRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateRole(body: UpdatePermissionRoleCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/Permission/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface ITemplateMessageClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateTemplateMessageCommand | undefined): Observable<CreateTemplateMessageResponse>;
    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    geList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<TemplateMessageListDto>;
    /**
     * @param templateMessageId (optional) 
     * @return OK
     */
    getById(templateMessageId: string | undefined): Observable<TemplateMessageDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateTemplateMessageCommand | undefined): Observable<CreateTemplateMessageResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TemplateMessageClient implements ITemplateMessageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    create(body: CreateTemplateMessageCommand | undefined): Observable<CreateTemplateMessageResponse> {
        let url_ = this.baseUrl + "/TemplateMessage/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateTemplateMessageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateTemplateMessageResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateTemplateMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTemplateMessageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTemplateMessageResponse>(null as any);
    }

    /**
     * @param pageSize (optional) 
     * @param page (optional) 
     * @param search (optional) 
     * @return OK
     */
    geList(pageSize: number | undefined, page: number | undefined, search: string | undefined): Observable<TemplateMessageListDto> {
        let url_ = this.baseUrl + "/TemplateMessage/GeList?";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateMessageListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateMessageListDto>;
        }));
    }

    protected processGeList(response: HttpResponseBase): Observable<TemplateMessageListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateMessageListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateMessageListDto>(null as any);
    }

    /**
     * @param templateMessageId (optional) 
     * @return OK
     */
    getById(templateMessageId: string | undefined): Observable<TemplateMessageDto> {
        let url_ = this.baseUrl + "/TemplateMessage/GetById?";
        if (templateMessageId === null)
            throw new Error("The parameter 'templateMessageId' cannot be null.");
        else if (templateMessageId !== undefined)
            url_ += "TemplateMessageId=" + encodeURIComponent("" + templateMessageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateMessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateMessageDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TemplateMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateMessageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    update(body: UpdateTemplateMessageCommand | undefined): Observable<CreateTemplateMessageResponse> {
        let url_ = this.baseUrl + "/TemplateMessage/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateTemplateMessageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateTemplateMessageResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CreateTemplateMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTemplateMessageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateTemplateMessageResponse>(null as any);
    }
}

export interface IWikiPointClient {
    /**
     * @param body (optional) 
     * @return OK
     */
    createWikiChannelPoint(body: CreateWikiChannelPointCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    createWikiMessageMapping(body: CreateWikiMessageMappingPointCommand | undefined): Observable<void>;
    /**
     * @param id (optional) 
     * @return OK
     */
    getWikiChannelPointById(id: string | undefined): Observable<WikiChannelPointDto>;
    /**
     * @param id (optional) 
     * @return OK
     */
    getWikiMessageMappingPointById(id: string | undefined): Observable<WikiMessageMappingPointDto>;
    /**
     * @param search (optional) 
     * @param pageSize (optional) 
     * @param page (optional) 
     * @return OK
     */
    getWikiPointList(search: string | undefined, pageSize: number | undefined, page: number | undefined): Observable<WikiPointListDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    sendWikiChannelPointChat(body: SendWikiChannelPointChatCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    sendWikiMessageMappingPointChat(body: SendWikiMessageMappingPointChatCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateWikiChannelPoint(body: UpdateWikiChannelPointCommand | undefined): Observable<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    updateWikiMessageMapping(body: UpdateWikiMessageMappingPointCommand | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class WikiPointClient implements IWikiPointClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createWikiChannelPoint(body: CreateWikiChannelPointCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WikiPoint/CreateWikiChannelPoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWikiChannelPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWikiChannelPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateWikiChannelPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    createWikiMessageMapping(body: CreateWikiMessageMappingPointCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WikiPoint/CreateWikiMessageMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWikiMessageMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWikiMessageMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateWikiMessageMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getWikiChannelPointById(id: string | undefined): Observable<WikiChannelPointDto> {
        let url_ = this.baseUrl + "/WikiPoint/GetWikiChannelPointById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWikiChannelPointById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWikiChannelPointById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WikiChannelPointDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WikiChannelPointDto>;
        }));
    }

    protected processGetWikiChannelPointById(response: HttpResponseBase): Observable<WikiChannelPointDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WikiChannelPointDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WikiChannelPointDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return OK
     */
    getWikiMessageMappingPointById(id: string | undefined): Observable<WikiMessageMappingPointDto> {
        let url_ = this.baseUrl + "/WikiPoint/GetWikiMessageMappingPointById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWikiMessageMappingPointById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWikiMessageMappingPointById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WikiMessageMappingPointDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WikiMessageMappingPointDto>;
        }));
    }

    protected processGetWikiMessageMappingPointById(response: HttpResponseBase): Observable<WikiMessageMappingPointDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WikiMessageMappingPointDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WikiMessageMappingPointDto>(null as any);
    }

    /**
     * @param search (optional) 
     * @param pageSize (optional) 
     * @param page (optional) 
     * @return OK
     */
    getWikiPointList(search: string | undefined, pageSize: number | undefined, page: number | undefined): Observable<WikiPointListDto> {
        let url_ = this.baseUrl + "/WikiPoint/GetWikiPointList?";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWikiPointList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWikiPointList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WikiPointListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WikiPointListDto>;
        }));
    }

    protected processGetWikiPointList(response: HttpResponseBase): Observable<WikiPointListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WikiPointListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WikiPointListDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendWikiChannelPointChat(body: SendWikiChannelPointChatCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WikiPoint/SendWikiChannelPointChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendWikiChannelPointChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendWikiChannelPointChat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendWikiChannelPointChat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    sendWikiMessageMappingPointChat(body: SendWikiMessageMappingPointChatCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WikiPoint/SendWikiMessageMappingPointChat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendWikiMessageMappingPointChat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendWikiMessageMappingPointChat(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendWikiMessageMappingPointChat(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateWikiChannelPoint(body: UpdateWikiChannelPointCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WikiPoint/UpdateWikiChannelPoint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWikiChannelPoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWikiChannelPoint(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateWikiChannelPoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateWikiMessageMapping(body: UpdateWikiMessageMappingPointCommand | undefined): Observable<void> {
        let url_ = this.baseUrl + "/WikiPoint/UpdateWikiMessageMapping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWikiMessageMapping(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWikiMessageMapping(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateWikiMessageMapping(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export class PaginationRequest implements IPaginationRequest {
    pageSize?: number;
    page?: number;
    readonly take?: number;
    readonly skip?: number;

    constructor(data?: IPaginationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.page = _data["page"];
            (<any>this).take = _data["take"];
            (<any>this).skip = _data["skip"];
        }
    }

    static fromJS(data: any): PaginationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["page"] = this.page;
        data["take"] = this.take;
        data["skip"] = this.skip;
        return data;
    }
}

export interface IPaginationRequest {
    pageSize?: number;
    page?: number;
    take?: number;
    skip?: number;
}

export class PaginationResult implements IPaginationResult {
    request?: PaginationRequest;
    readonly totalItems?: number;
    readonly totalPages?: number;
    readonly hasNext?: boolean;
    readonly hasPrevious?: boolean;

    constructor(data?: IPaginationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.request = _data["request"] ? PaginationRequest.fromJS(_data["request"]) : <any>undefined;
            (<any>this).totalItems = _data["totalItems"];
            (<any>this).totalPages = _data["totalPages"];
            (<any>this).hasNext = _data["hasNext"];
            (<any>this).hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginationResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["totalItems"] = this.totalItems;
        data["totalPages"] = this.totalPages;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

export interface IPaginationResult {
    request?: PaginationRequest;
    totalItems?: number;
    totalPages?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;
}

export class AttachChannelPathApiCallingBasedCommand implements IAttachChannelPathApiCallingBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;
    api?: ApiSpec;
    beforeChannelPathId?: string | undefined;

    constructor(data?: IAttachChannelPathApiCallingBasedCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.channelId = _data["channelId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
            this.api = _data["api"] ? ApiSpec.fromJS(_data["api"]) : <any>undefined;
            this.beforeChannelPathId = _data["beforeChannelPathId"];
        }
    }

    static fromJS(data: any): AttachChannelPathApiCallingBasedCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AttachChannelPathApiCallingBasedCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["channelId"] = this.channelId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        data["api"] = this.api ? this.api.toJSON() : <any>undefined;
        data["beforeChannelPathId"] = this.beforeChannelPathId;
        return data;
    }
}

export interface IAttachChannelPathApiCallingBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;
    api?: ApiSpec;
    beforeChannelPathId?: string | undefined;
}

export class AttachChannelPathCompleteBasedCommand implements IAttachChannelPathCompleteBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;
    completedType?: ChannelPathCompletedType;
    beforeChannelPathId?: string | undefined;

    constructor(data?: IAttachChannelPathCompleteBasedCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.channelId = _data["channelId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
            this.completedType = _data["completedType"];
            this.beforeChannelPathId = _data["beforeChannelPathId"];
        }
    }

    static fromJS(data: any): AttachChannelPathCompleteBasedCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AttachChannelPathCompleteBasedCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["channelId"] = this.channelId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        data["completedType"] = this.completedType;
        data["beforeChannelPathId"] = this.beforeChannelPathId;
        return data;
    }
}

export interface IAttachChannelPathCompleteBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;
    completedType?: ChannelPathCompletedType;
    beforeChannelPathId?: string | undefined;
}

export class AttachChannelPathConditionBasedCommand implements IAttachChannelPathConditionBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;
    resolvers?: ConditionResolverItem[] | undefined;
    beforeChannelPathId?: string | undefined;

    constructor(data?: IAttachChannelPathConditionBasedCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.channelId = _data["channelId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
            if (Array.isArray(_data["resolvers"])) {
                this.resolvers = [] as any;
                for (let item of _data["resolvers"])
                    this.resolvers!.push(ConditionResolverItem.fromJS(item));
            }
            this.beforeChannelPathId = _data["beforeChannelPathId"];
        }
    }

    static fromJS(data: any): AttachChannelPathConditionBasedCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AttachChannelPathConditionBasedCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["channelId"] = this.channelId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        if (Array.isArray(this.resolvers)) {
            data["resolvers"] = [];
            for (let item of this.resolvers)
                data["resolvers"].push(item.toJSON());
        }
        data["beforeChannelPathId"] = this.beforeChannelPathId;
        return data;
    }
}

export interface IAttachChannelPathConditionBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;
    resolvers?: ConditionResolverItem[] | undefined;
    beforeChannelPathId?: string | undefined;
}

export class AttachChannelPathMapperBasedCommand implements IAttachChannelPathMapperBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string;
    beforeChannelPathId?: string | undefined;
    actions?: string[] | undefined;

    constructor(data?: IAttachChannelPathMapperBasedCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.channelId = _data["channelId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.messageMappingId = _data["messageMappingId"];
            this.beforeChannelPathId = _data["beforeChannelPathId"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
        }
    }

    static fromJS(data: any): AttachChannelPathMapperBasedCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AttachChannelPathMapperBasedCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["channelId"] = this.channelId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["messageMappingId"] = this.messageMappingId;
        data["beforeChannelPathId"] = this.beforeChannelPathId;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data;
    }
}

export interface IAttachChannelPathMapperBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string;
    beforeChannelPathId?: string | undefined;
    actions?: string[] | undefined;
}

export class AttachChannelPathResponse implements IAttachChannelPathResponse {
    pathId?: string;

    constructor(data?: IAttachChannelPathResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pathId = _data["pathId"];
        }
    }

    static fromJS(data: any): AttachChannelPathResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AttachChannelPathResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pathId"] = this.pathId;
        return data;
    }
}

export interface IAttachChannelPathResponse {
    pathId?: string;
}

export class AttachChannelPathStartBasedCommand implements IAttachChannelPathStartBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;

    constructor(data?: IAttachChannelPathStartBasedCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.channelId = _data["channelId"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
        }
    }

    static fromJS(data: any): AttachChannelPathStartBasedCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AttachChannelPathStartBasedCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["channelId"] = this.channelId;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data;
    }
}

export interface IAttachChannelPathStartBasedCommand {
    commandId?: string;
    channelId?: string;
    name?: string | undefined;
    description?: string | undefined;
    actions?: string[] | undefined;
}

export class ConditionResolverItem implements IConditionResolverItem {
    priority?: number;
    statusName?: string | undefined;
    outgoingHttpResponseStatus?: number | undefined;
    actions?: string[] | undefined;
    type?: ConditionResolverType;
    expectedIncomingHttpResponseStatuses?: number[] | undefined;
    expectedIncomingHttpStatusRangeCode?: HttpStatusRangeCode;
    conditions?: PropertyValueCondition[] | undefined;
    conditionRelationship?: ConditionRelationshipType;
    expected?: boolean;
    property?: string | undefined;
    expectedValues?: PropertyExpectedValue[] | undefined;

    constructor(data?: IConditionResolverItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priority = _data["priority"];
            this.statusName = _data["statusName"];
            this.outgoingHttpResponseStatus = _data["outgoingHttpResponseStatus"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
            this.type = _data["type"];
            if (Array.isArray(_data["expectedIncomingHttpResponseStatuses"])) {
                this.expectedIncomingHttpResponseStatuses = [] as any;
                for (let item of _data["expectedIncomingHttpResponseStatuses"])
                    this.expectedIncomingHttpResponseStatuses!.push(item);
            }
            this.expectedIncomingHttpStatusRangeCode = _data["expectedIncomingHttpStatusRangeCode"] ? HttpStatusRangeCode.fromJS(_data["expectedIncomingHttpStatusRangeCode"]) : <any>undefined;
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(PropertyValueCondition.fromJS(item));
            }
            this.conditionRelationship = _data["conditionRelationship"];
            this.expected = _data["expected"];
            this.property = _data["property"];
            if (Array.isArray(_data["expectedValues"])) {
                this.expectedValues = [] as any;
                for (let item of _data["expectedValues"])
                    this.expectedValues!.push(PropertyExpectedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionResolverItem {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionResolverItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority;
        data["statusName"] = this.statusName;
        data["outgoingHttpResponseStatus"] = this.outgoingHttpResponseStatus;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        data["type"] = this.type;
        if (Array.isArray(this.expectedIncomingHttpResponseStatuses)) {
            data["expectedIncomingHttpResponseStatuses"] = [];
            for (let item of this.expectedIncomingHttpResponseStatuses)
                data["expectedIncomingHttpResponseStatuses"].push(item);
        }
        data["expectedIncomingHttpStatusRangeCode"] = this.expectedIncomingHttpStatusRangeCode ? this.expectedIncomingHttpStatusRangeCode.toJSON() : <any>undefined;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["conditionRelationship"] = this.conditionRelationship;
        data["expected"] = this.expected;
        data["property"] = this.property;
        if (Array.isArray(this.expectedValues)) {
            data["expectedValues"] = [];
            for (let item of this.expectedValues)
                data["expectedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConditionResolverItem {
    priority?: number;
    statusName?: string | undefined;
    outgoingHttpResponseStatus?: number | undefined;
    actions?: string[] | undefined;
    type?: ConditionResolverType;
    expectedIncomingHttpResponseStatuses?: number[] | undefined;
    expectedIncomingHttpStatusRangeCode?: HttpStatusRangeCode;
    conditions?: PropertyValueCondition[] | undefined;
    conditionRelationship?: ConditionRelationshipType;
    expected?: boolean;
    property?: string | undefined;
    expectedValues?: PropertyExpectedValue[] | undefined;
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateCategoryCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
}

export class CreateCategoryResponse implements ICreateCategoryResponse {
    id?: string;

    constructor(data?: ICreateCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateCategoryResponse {
    id?: string;
}

export class CreateChannelCommand implements ICreateChannelCommand {
    commandId?: string;
    name?: string | undefined;
    companyId?: string;
    description?: string | undefined;
    actions?: string[] | undefined;

    constructor(data?: ICreateChannelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.description = _data["description"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateChannelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChannelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["description"] = this.description;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data;
    }
}

export interface ICreateChannelCommand {
    commandId?: string;
    name?: string | undefined;
    companyId?: string;
    description?: string | undefined;
    actions?: string[] | undefined;
}

export class CreateChannelResponse implements ICreateChannelResponse {
    id?: string;

    constructor(data?: ICreateChannelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateChannelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateChannelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateChannelResponse {
    id?: string;
}

export class CreateCompanyCommand implements ICreateCompanyCommand {
    commandId?: string;
    name?: string | undefined;
    icon?: string | undefined;

    constructor(data?: ICreateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.icon = _data["icon"];
        }
    }

    static fromJS(data: any): CreateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["icon"] = this.icon;
        return data;
    }
}

export interface ICreateCompanyCommand {
    commandId?: string;
    name?: string | undefined;
    icon?: string | undefined;
}

export class CreateCompanyResponse implements ICreateCompanyResponse {
    id?: string;

    constructor(data?: ICreateCompanyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateCompanyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateCompanyResponse {
    id?: string;
}

export class CreateDataMappingCommand implements ICreateDataMappingCommand {
    commandId?: string;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    destinationIntegrationPointId?: string;
    description?: string | undefined;
    items?: DataMappingItem[] | undefined;

    constructor(data?: ICreateDataMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.sourceIntegrationPointId = _data["sourceIntegrationPointId"];
            this.destinationIntegrationPointId = _data["destinationIntegrationPointId"];
            this.description = _data["description"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DataMappingItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateDataMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDataMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["sourceIntegrationPointId"] = this.sourceIntegrationPointId;
        data["destinationIntegrationPointId"] = this.destinationIntegrationPointId;
        data["description"] = this.description;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateDataMappingCommand {
    commandId?: string;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    destinationIntegrationPointId?: string;
    description?: string | undefined;
    items?: DataMappingItem[] | undefined;
}

export class CreateDataMappingResponse implements ICreateDataMappingResponse {
    id?: string;

    constructor(data?: ICreateDataMappingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateDataMappingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDataMappingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateDataMappingResponse {
    id?: string;
}

export class CreateIntegrationPointCommand implements ICreateIntegrationPointCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateIntegrationPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateIntegrationPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIntegrationPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateIntegrationPointCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
}

export class CreateIntegrationPointResponse implements ICreateIntegrationPointResponse {
    id?: string;

    constructor(data?: ICreateIntegrationPointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateIntegrationPointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIntegrationPointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateIntegrationPointResponse {
    id?: string;
}

export class CreateMessageMappingResponse implements ICreateMessageMappingResponse {
    id?: string;

    constructor(data?: ICreateMessageMappingResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateMessageMappingResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageMappingResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateMessageMappingResponse {
    id?: string;
}

export class CreateMessageStaticMappingCommand implements ICreateMessageStaticMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    message?: ChannelPathMessage;

    constructor(data?: ICreateMessageStaticMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.message = _data["message"] ? ChannelPathMessage.fromJS(_data["message"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateMessageStaticMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageStaticMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateMessageStaticMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    message?: ChannelPathMessage;
}

export class CreateMessageWithMappingCommand implements ICreateMessageWithMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    sourceTemplateMessageId?: string;
    destinationTemplateMessageId?: string;
    dataMappings?: PropertyDataMapping[] | undefined;
    mappingItems?: PropertyMappingItem[] | undefined;

    constructor(data?: ICreateMessageWithMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sourceTemplateMessageId = _data["sourceTemplateMessageId"];
            this.destinationTemplateMessageId = _data["destinationTemplateMessageId"];
            if (Array.isArray(_data["dataMappings"])) {
                this.dataMappings = [] as any;
                for (let item of _data["dataMappings"])
                    this.dataMappings!.push(PropertyDataMapping.fromJS(item));
            }
            if (Array.isArray(_data["mappingItems"])) {
                this.mappingItems = [] as any;
                for (let item of _data["mappingItems"])
                    this.mappingItems!.push(PropertyMappingItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateMessageWithMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageWithMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sourceTemplateMessageId"] = this.sourceTemplateMessageId;
        data["destinationTemplateMessageId"] = this.destinationTemplateMessageId;
        if (Array.isArray(this.dataMappings)) {
            data["dataMappings"] = [];
            for (let item of this.dataMappings)
                data["dataMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.mappingItems)) {
            data["mappingItems"] = [];
            for (let item of this.mappingItems)
                data["mappingItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateMessageWithMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    sourceTemplateMessageId?: string;
    destinationTemplateMessageId?: string;
    dataMappings?: PropertyDataMapping[] | undefined;
    mappingItems?: PropertyMappingItem[] | undefined;
}

export class CreateMessageWithoutMappingCommand implements ICreateMessageWithoutMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateMessageWithoutMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateMessageWithoutMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMessageWithoutMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateMessageWithoutMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
}

export class CreateTemplateMessageCommand implements ICreateTemplateMessageCommand {
    commandId?: string;
    name?: string | undefined;
    json?: string | undefined;
    integrationPointId?: string;
    description?: string | undefined;

    constructor(data?: ICreateTemplateMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.json = _data["json"];
            this.integrationPointId = _data["integrationPointId"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateTemplateMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTemplateMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["json"] = this.json;
        data["integrationPointId"] = this.integrationPointId;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateTemplateMessageCommand {
    commandId?: string;
    name?: string | undefined;
    json?: string | undefined;
    integrationPointId?: string;
    description?: string | undefined;
}

export class CreateTemplateMessageResponse implements ICreateTemplateMessageResponse {
    id?: string;

    constructor(data?: ICreateTemplateMessageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateTemplateMessageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTemplateMessageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateTemplateMessageResponse {
    id?: string;
}

export class CreateWikiChannelPointCommand implements ICreateWikiChannelPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    text?: string | undefined;
    channelId?: string | undefined;
    tags?: string[] | undefined;

    constructor(data?: ICreateWikiChannelPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.topic = _data["topic"];
            this.description = _data["description"];
            this.text = _data["text"];
            this.channelId = _data["channelId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateWikiChannelPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWikiChannelPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["topic"] = this.topic;
        data["description"] = this.description;
        data["text"] = this.text;
        data["channelId"] = this.channelId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ICreateWikiChannelPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    text?: string | undefined;
    channelId?: string | undefined;
    tags?: string[] | undefined;
}

export class CreateWikiMessageMappingPointCommand implements ICreateWikiMessageMappingPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string | undefined;
    tags?: string[] | undefined;

    constructor(data?: ICreateWikiMessageMappingPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.topic = _data["topic"];
            this.description = _data["description"];
            this.messageMappingId = _data["messageMappingId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateWikiMessageMappingPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWikiMessageMappingPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["topic"] = this.topic;
        data["description"] = this.description;
        data["messageMappingId"] = this.messageMappingId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ICreateWikiMessageMappingPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string | undefined;
    tags?: string[] | undefined;
}

export class DeleteChannelCommand implements IDeleteChannelCommand {
    commandId?: string;
    id?: string;

    constructor(data?: IDeleteChannelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DeleteChannelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteChannelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDeleteChannelCommand {
    commandId?: string;
    id?: string;
}

export class DeleteChannelPathCommand implements IDeleteChannelPathCommand {
    commandId?: string;
    channelId?: string;
    channelPathId?: string;

    constructor(data?: IDeleteChannelPathCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.channelId = _data["channelId"];
            this.channelPathId = _data["channelPathId"];
        }
    }

    static fromJS(data: any): DeleteChannelPathCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteChannelPathCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["channelId"] = this.channelId;
        data["channelPathId"] = this.channelPathId;
        return data;
    }
}

export interface IDeleteChannelPathCommand {
    commandId?: string;
    channelId?: string;
    channelPathId?: string;
}

export class PropertyDataMapping implements IPropertyDataMapping {
    dataMappingId?: string;
    property?: string | undefined;
    dataMappingDirection?: DataMappingDirection;

    constructor(data?: IPropertyDataMapping) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataMappingId = _data["dataMappingId"];
            this.property = _data["property"];
            this.dataMappingDirection = _data["dataMappingDirection"];
        }
    }

    static fromJS(data: any): PropertyDataMapping {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDataMapping();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataMappingId"] = this.dataMappingId;
        data["property"] = this.property;
        data["dataMappingDirection"] = this.dataMappingDirection;
        return data;
    }
}

export interface IPropertyDataMapping {
    dataMappingId?: string;
    property?: string | undefined;
    dataMappingDirection?: DataMappingDirection;
}

export class SendWikiChannelPointChatCommand implements ISendWikiChannelPointChatCommand {
    commandId?: string;
    wikiId?: string;
    text?: string | undefined;
    replyTo?: string | undefined;
    pathChannelMentions?: WikiPointPathChannelMention[] | undefined;

    constructor(data?: ISendWikiChannelPointChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.wikiId = _data["wikiId"];
            this.text = _data["text"];
            this.replyTo = _data["replyTo"];
            if (Array.isArray(_data["pathChannelMentions"])) {
                this.pathChannelMentions = [] as any;
                for (let item of _data["pathChannelMentions"])
                    this.pathChannelMentions!.push(WikiPointPathChannelMention.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendWikiChannelPointChatCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendWikiChannelPointChatCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["wikiId"] = this.wikiId;
        data["text"] = this.text;
        data["replyTo"] = this.replyTo;
        if (Array.isArray(this.pathChannelMentions)) {
            data["pathChannelMentions"] = [];
            for (let item of this.pathChannelMentions)
                data["pathChannelMentions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendWikiChannelPointChatCommand {
    commandId?: string;
    wikiId?: string;
    text?: string | undefined;
    replyTo?: string | undefined;
    pathChannelMentions?: WikiPointPathChannelMention[] | undefined;
}

export class SendWikiMessageMappingPointChatCommand implements ISendWikiMessageMappingPointChatCommand {
    commandId?: string;
    wikiId?: string;
    text?: string | undefined;
    replyTo?: string | undefined;
    templateMessageMentions?: WikiPointTemplateMessageMention[] | undefined;
    propertyMappingMentions?: WikiPointPropertyMappingMention[] | undefined;

    constructor(data?: ISendWikiMessageMappingPointChatCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.wikiId = _data["wikiId"];
            this.text = _data["text"];
            this.replyTo = _data["replyTo"];
            if (Array.isArray(_data["templateMessageMentions"])) {
                this.templateMessageMentions = [] as any;
                for (let item of _data["templateMessageMentions"])
                    this.templateMessageMentions!.push(WikiPointTemplateMessageMention.fromJS(item));
            }
            if (Array.isArray(_data["propertyMappingMentions"])) {
                this.propertyMappingMentions = [] as any;
                for (let item of _data["propertyMappingMentions"])
                    this.propertyMappingMentions!.push(WikiPointPropertyMappingMention.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SendWikiMessageMappingPointChatCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendWikiMessageMappingPointChatCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["wikiId"] = this.wikiId;
        data["text"] = this.text;
        data["replyTo"] = this.replyTo;
        if (Array.isArray(this.templateMessageMentions)) {
            data["templateMessageMentions"] = [];
            for (let item of this.templateMessageMentions)
                data["templateMessageMentions"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyMappingMentions)) {
            data["propertyMappingMentions"] = [];
            for (let item of this.propertyMappingMentions)
                data["propertyMappingMentions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISendWikiMessageMappingPointChatCommand {
    commandId?: string;
    wikiId?: string;
    text?: string | undefined;
    replyTo?: string | undefined;
    templateMessageMentions?: WikiPointTemplateMessageMention[] | undefined;
    propertyMappingMentions?: WikiPointPropertyMappingMention[] | undefined;
}

export class SetNextChannelPathCommand implements ISetNextChannelPathCommand {
    commandId?: string;
    channelId?: string;
    channelPathId?: string;
    resolverId?: string | undefined;
    nextChannelPathId?: string;

    constructor(data?: ISetNextChannelPathCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.channelId = _data["channelId"];
            this.channelPathId = _data["channelPathId"];
            this.resolverId = _data["resolverId"];
            this.nextChannelPathId = _data["nextChannelPathId"];
        }
    }

    static fromJS(data: any): SetNextChannelPathCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetNextChannelPathCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["channelId"] = this.channelId;
        data["channelPathId"] = this.channelPathId;
        data["resolverId"] = this.resolverId;
        data["nextChannelPathId"] = this.nextChannelPathId;
        return data;
    }
}

export interface ISetNextChannelPathCommand {
    commandId?: string;
    channelId?: string;
    channelPathId?: string;
    resolverId?: string | undefined;
    nextChannelPathId?: string;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    id?: string;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateCategoryCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    id?: string;
}

export class UpdateChannelCommand implements IUpdateChannelCommand {
    commandId?: string;
    name?: string | undefined;
    companyId?: string;
    description?: string | undefined;
    actions?: string[] | undefined;
    id?: string;

    constructor(data?: IUpdateChannelCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.description = _data["description"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateChannelCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateChannelCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["description"] = this.description;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateChannelCommand {
    commandId?: string;
    name?: string | undefined;
    companyId?: string;
    description?: string | undefined;
    actions?: string[] | undefined;
    id?: string;
}

export class UpdateCompanyCommand implements IUpdateCompanyCommand {
    commandId?: string;
    name?: string | undefined;
    icon?: string | undefined;
    id?: string;

    constructor(data?: IUpdateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateCompanyCommand {
    commandId?: string;
    name?: string | undefined;
    icon?: string | undefined;
    id?: string;
}

export class UpdateDataMappingCommand implements IUpdateDataMappingCommand {
    commandId?: string;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    destinationIntegrationPointId?: string;
    description?: string | undefined;
    items?: DataMappingItem[] | undefined;
    id?: string;

    constructor(data?: IUpdateDataMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.sourceIntegrationPointId = _data["sourceIntegrationPointId"];
            this.destinationIntegrationPointId = _data["destinationIntegrationPointId"];
            this.description = _data["description"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DataMappingItem.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateDataMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDataMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["sourceIntegrationPointId"] = this.sourceIntegrationPointId;
        data["destinationIntegrationPointId"] = this.destinationIntegrationPointId;
        data["description"] = this.description;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateDataMappingCommand {
    commandId?: string;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    destinationIntegrationPointId?: string;
    description?: string | undefined;
    items?: DataMappingItem[] | undefined;
    id?: string;
}

export class UpdateIntegrationPointCommand implements IUpdateIntegrationPointCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    id?: string;

    constructor(data?: IUpdateIntegrationPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateIntegrationPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIntegrationPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateIntegrationPointCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    id?: string;
}

export class UpdateMessageStaticMappingCommand implements IUpdateMessageStaticMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    message?: ChannelPathMessage;
    id?: string;

    constructor(data?: IUpdateMessageStaticMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.message = _data["message"] ? ChannelPathMessage.fromJS(_data["message"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateMessageStaticMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageStaticMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["message"] = this.message ? this.message.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateMessageStaticMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    message?: ChannelPathMessage;
    id?: string;
}

export class UpdateMessageWithMappingCommand implements IUpdateMessageWithMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    sourceTemplateMessageId?: string;
    destinationTemplateMessageId?: string;
    dataMappings?: PropertyDataMapping[] | undefined;
    mappingItems?: PropertyMappingItem[] | undefined;
    id?: string;

    constructor(data?: IUpdateMessageWithMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sourceTemplateMessageId = _data["sourceTemplateMessageId"];
            this.destinationTemplateMessageId = _data["destinationTemplateMessageId"];
            if (Array.isArray(_data["dataMappings"])) {
                this.dataMappings = [] as any;
                for (let item of _data["dataMappings"])
                    this.dataMappings!.push(PropertyDataMapping.fromJS(item));
            }
            if (Array.isArray(_data["mappingItems"])) {
                this.mappingItems = [] as any;
                for (let item of _data["mappingItems"])
                    this.mappingItems!.push(PropertyMappingItem.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateMessageWithMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageWithMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sourceTemplateMessageId"] = this.sourceTemplateMessageId;
        data["destinationTemplateMessageId"] = this.destinationTemplateMessageId;
        if (Array.isArray(this.dataMappings)) {
            data["dataMappings"] = [];
            for (let item of this.dataMappings)
                data["dataMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.mappingItems)) {
            data["mappingItems"] = [];
            for (let item of this.mappingItems)
                data["mappingItems"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateMessageWithMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    sourceTemplateMessageId?: string;
    destinationTemplateMessageId?: string;
    dataMappings?: PropertyDataMapping[] | undefined;
    mappingItems?: PropertyMappingItem[] | undefined;
    id?: string;
}

export class UpdateMessageWithoutMappingCommand implements IUpdateMessageWithoutMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    id?: string;

    constructor(data?: IUpdateMessageWithoutMappingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateMessageWithoutMappingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMessageWithoutMappingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateMessageWithoutMappingCommand {
    commandId?: string;
    name?: string | undefined;
    description?: string | undefined;
    id?: string;
}

export class UpdateTemplateMessageCommand implements IUpdateTemplateMessageCommand {
    commandId?: string;
    name?: string | undefined;
    json?: string | undefined;
    integrationPointId?: string;
    description?: string | undefined;
    id?: string;

    constructor(data?: IUpdateTemplateMessageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.name = _data["name"];
            this.json = _data["json"];
            this.integrationPointId = _data["integrationPointId"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateTemplateMessageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTemplateMessageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["name"] = this.name;
        data["json"] = this.json;
        data["integrationPointId"] = this.integrationPointId;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateTemplateMessageCommand {
    commandId?: string;
    name?: string | undefined;
    json?: string | undefined;
    integrationPointId?: string;
    description?: string | undefined;
    id?: string;
}

export class UpdateWikiChannelPointCommand implements IUpdateWikiChannelPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    text?: string | undefined;
    channelId?: string | undefined;
    tags?: string[] | undefined;
    id?: string;

    constructor(data?: IUpdateWikiChannelPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.topic = _data["topic"];
            this.description = _data["description"];
            this.text = _data["text"];
            this.channelId = _data["channelId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWikiChannelPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWikiChannelPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["topic"] = this.topic;
        data["description"] = this.description;
        data["text"] = this.text;
        data["channelId"] = this.channelId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateWikiChannelPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    text?: string | undefined;
    channelId?: string | undefined;
    tags?: string[] | undefined;
    id?: string;
}

export class UpdateWikiMessageMappingPointCommand implements IUpdateWikiMessageMappingPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string | undefined;
    tags?: string[] | undefined;
    id?: string;

    constructor(data?: IUpdateWikiMessageMappingPointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.topic = _data["topic"];
            this.description = _data["description"];
            this.messageMappingId = _data["messageMappingId"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateWikiMessageMappingPointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateWikiMessageMappingPointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["topic"] = this.topic;
        data["description"] = this.description;
        data["messageMappingId"] = this.messageMappingId;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUpdateWikiMessageMappingPointCommand {
    commandId?: string;
    topic?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string | undefined;
    tags?: string[] | undefined;
    id?: string;
}

export class CategoryDto implements ICategoryDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface ICategoryDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
}

export class CategoryListDto implements ICategoryListDto {
    items?: CategoryDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: ICategoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICategoryListDto {
    items?: CategoryDto[] | undefined;
    pagination?: PaginationResult;
}

export class ChannelDto implements IChannelDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    companyId?: string;
    description?: string | undefined;
    paths?: ChannelPathItem[] | undefined;
    actions?: ActionItem[] | undefined;

    constructor(data?: IChannelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.companyId = _data["companyId"];
            this.description = _data["description"];
            if (Array.isArray(_data["paths"])) {
                this.paths = [] as any;
                for (let item of _data["paths"])
                    this.paths!.push(ChannelPathItem.fromJS(item));
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(ActionItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChannelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["companyId"] = this.companyId;
        data["description"] = this.description;
        if (Array.isArray(this.paths)) {
            data["paths"] = [];
            for (let item of this.paths)
                data["paths"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChannelDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    companyId?: string;
    description?: string | undefined;
    paths?: ChannelPathItem[] | undefined;
    actions?: ActionItem[] | undefined;
}

export class ChannelListDto implements IChannelListDto {
    items?: ChannelDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IChannelListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChannelDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ChannelListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IChannelListDto {
    items?: ChannelDto[] | undefined;
    pagination?: PaginationResult;
}

export class ChannelPathItem implements IChannelPathItem {
    id?: string;
    createdAt?: Date;
    type?: ChannelPathType;
    completedType?: ChannelPathCompletedType;
    name?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string | undefined;
    nextChannelPathId?: string | undefined;
    nextChannelPathName?: string | undefined;
    api?: ApiSpec;
    resolvers?: ConditionResolverItem2[] | undefined;

    constructor(data?: IChannelPathItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.completedType = _data["completedType"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.messageMappingId = _data["messageMappingId"];
            this.nextChannelPathId = _data["nextChannelPathId"];
            this.nextChannelPathName = _data["nextChannelPathName"];
            this.api = _data["api"] ? ApiSpec.fromJS(_data["api"]) : <any>undefined;
            if (Array.isArray(_data["resolvers"])) {
                this.resolvers = [] as any;
                for (let item of _data["resolvers"])
                    this.resolvers!.push(ConditionResolverItem2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChannelPathItem {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelPathItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["completedType"] = this.completedType;
        data["name"] = this.name;
        data["description"] = this.description;
        data["messageMappingId"] = this.messageMappingId;
        data["nextChannelPathId"] = this.nextChannelPathId;
        data["nextChannelPathName"] = this.nextChannelPathName;
        data["api"] = this.api ? this.api.toJSON() : <any>undefined;
        if (Array.isArray(this.resolvers)) {
            data["resolvers"] = [];
            for (let item of this.resolvers)
                data["resolvers"].push(item.toJSON());
        }
        return data;
    }
}

export interface IChannelPathItem {
    id?: string;
    createdAt?: Date;
    type?: ChannelPathType;
    completedType?: ChannelPathCompletedType;
    name?: string | undefined;
    description?: string | undefined;
    messageMappingId?: string | undefined;
    nextChannelPathId?: string | undefined;
    nextChannelPathName?: string | undefined;
    api?: ApiSpec;
    resolvers?: ConditionResolverItem2[] | undefined;
}

export class CompanyDto implements ICompanyDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    icon?: string | undefined;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.icon = _data["icon"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["icon"] = this.icon;
        return data;
    }
}

export interface ICompanyDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    icon?: string | undefined;
}

export class CompanyListDto implements ICompanyListDto {
    items?: CompanyDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: ICompanyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CompanyDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICompanyListDto {
    items?: CompanyDto[] | undefined;
    pagination?: PaginationResult;
}

export class ConditionResolverItem2 implements IConditionResolverItem2 {
    id?: string;
    type?: ConditionResolverType;
    priority?: number;
    statusName?: string | undefined;
    outgoingHttpResponseStatus?: number | undefined;
    nextChannelPathId?: string;
    nextChannelPathName?: string | undefined;
    actions?: ActionItem[] | undefined;
    expectedIncomingHttpResponseStatuses?: number[] | undefined;
    expectedIncomingHttpStatusRangeCode?: HttpStatusRangeCode;
    conditions?: PropertyValueCondition[] | undefined;
    conditionRelationship?: ConditionRelationshipType;
    expected?: boolean;
    property?: string | undefined;
    expectedValues?: PropertyExpectedValue[] | undefined;

    constructor(data?: IConditionResolverItem2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.priority = _data["priority"];
            this.statusName = _data["statusName"];
            this.outgoingHttpResponseStatus = _data["outgoingHttpResponseStatus"];
            this.nextChannelPathId = _data["nextChannelPathId"];
            this.nextChannelPathName = _data["nextChannelPathName"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(ActionItem.fromJS(item));
            }
            if (Array.isArray(_data["expectedIncomingHttpResponseStatuses"])) {
                this.expectedIncomingHttpResponseStatuses = [] as any;
                for (let item of _data["expectedIncomingHttpResponseStatuses"])
                    this.expectedIncomingHttpResponseStatuses!.push(item);
            }
            this.expectedIncomingHttpStatusRangeCode = _data["expectedIncomingHttpStatusRangeCode"] ? HttpStatusRangeCode.fromJS(_data["expectedIncomingHttpStatusRangeCode"]) : <any>undefined;
            if (Array.isArray(_data["conditions"])) {
                this.conditions = [] as any;
                for (let item of _data["conditions"])
                    this.conditions!.push(PropertyValueCondition.fromJS(item));
            }
            this.conditionRelationship = _data["conditionRelationship"];
            this.expected = _data["expected"];
            this.property = _data["property"];
            if (Array.isArray(_data["expectedValues"])) {
                this.expectedValues = [] as any;
                for (let item of _data["expectedValues"])
                    this.expectedValues!.push(PropertyExpectedValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConditionResolverItem2 {
        data = typeof data === 'object' ? data : {};
        let result = new ConditionResolverItem2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["priority"] = this.priority;
        data["statusName"] = this.statusName;
        data["outgoingHttpResponseStatus"] = this.outgoingHttpResponseStatus;
        data["nextChannelPathId"] = this.nextChannelPathId;
        data["nextChannelPathName"] = this.nextChannelPathName;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        if (Array.isArray(this.expectedIncomingHttpResponseStatuses)) {
            data["expectedIncomingHttpResponseStatuses"] = [];
            for (let item of this.expectedIncomingHttpResponseStatuses)
                data["expectedIncomingHttpResponseStatuses"].push(item);
        }
        data["expectedIncomingHttpStatusRangeCode"] = this.expectedIncomingHttpStatusRangeCode ? this.expectedIncomingHttpStatusRangeCode.toJSON() : <any>undefined;
        if (Array.isArray(this.conditions)) {
            data["conditions"] = [];
            for (let item of this.conditions)
                data["conditions"].push(item.toJSON());
        }
        data["conditionRelationship"] = this.conditionRelationship;
        data["expected"] = this.expected;
        data["property"] = this.property;
        if (Array.isArray(this.expectedValues)) {
            data["expectedValues"] = [];
            for (let item of this.expectedValues)
                data["expectedValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IConditionResolverItem2 {
    id?: string;
    type?: ConditionResolverType;
    priority?: number;
    statusName?: string | undefined;
    outgoingHttpResponseStatus?: number | undefined;
    nextChannelPathId?: string;
    nextChannelPathName?: string | undefined;
    actions?: ActionItem[] | undefined;
    expectedIncomingHttpResponseStatuses?: number[] | undefined;
    expectedIncomingHttpStatusRangeCode?: HttpStatusRangeCode;
    conditions?: PropertyValueCondition[] | undefined;
    conditionRelationship?: ConditionRelationshipType;
    expected?: boolean;
    property?: string | undefined;
    expectedValues?: PropertyExpectedValue[] | undefined;
}

export class DataMappingDto implements IDataMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    sourceIntegrationPointName?: string | undefined;
    destinationIntegrationPointId?: string;
    destinationIntegrationPointName?: string | undefined;
    description?: string | undefined;

    constructor(data?: IDataMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.sourceIntegrationPointId = _data["sourceIntegrationPointId"];
            this.sourceIntegrationPointName = _data["sourceIntegrationPointName"];
            this.destinationIntegrationPointId = _data["destinationIntegrationPointId"];
            this.destinationIntegrationPointName = _data["destinationIntegrationPointName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): DataMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["sourceIntegrationPointId"] = this.sourceIntegrationPointId;
        data["sourceIntegrationPointName"] = this.sourceIntegrationPointName;
        data["destinationIntegrationPointId"] = this.destinationIntegrationPointId;
        data["destinationIntegrationPointName"] = this.destinationIntegrationPointName;
        data["description"] = this.description;
        return data;
    }
}

export interface IDataMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    sourceIntegrationPointName?: string | undefined;
    destinationIntegrationPointId?: string;
    destinationIntegrationPointName?: string | undefined;
    description?: string | undefined;
}

export class DataMappingFullDto implements IDataMappingFullDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    destinationIntegrationPointId?: string;
    description?: string | undefined;
    items?: DataMappingItem[] | undefined;

    constructor(data?: IDataMappingFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.sourceIntegrationPointId = _data["sourceIntegrationPointId"];
            this.destinationIntegrationPointId = _data["destinationIntegrationPointId"];
            this.description = _data["description"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DataMappingItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DataMappingFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataMappingFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["sourceIntegrationPointId"] = this.sourceIntegrationPointId;
        data["destinationIntegrationPointId"] = this.destinationIntegrationPointId;
        data["description"] = this.description;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDataMappingFullDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    sourceIntegrationPointId?: string;
    destinationIntegrationPointId?: string;
    description?: string | undefined;
    items?: DataMappingItem[] | undefined;
}

export class DataMappingListDto implements IDataMappingListDto {
    items?: DataMappingDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IDataMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DataMappingDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DataMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDataMappingListDto {
    items?: DataMappingDto[] | undefined;
    pagination?: PaginationResult;
}

export class IntegrationPointDto implements IIntegrationPointDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IIntegrationPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IntegrationPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IIntegrationPointDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
}

export class IntegrationPointListDto implements IIntegrationPointListDto {
    items?: IntegrationPointDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IIntegrationPointListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IntegrationPointDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntegrationPointListDto {
        data = typeof data === 'object' ? data : {};
        let result = new IntegrationPointListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIntegrationPointListDto {
    items?: IntegrationPointDto[] | undefined;
    pagination?: PaginationResult;
}

export class MessageMappingDto implements IMessageMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
    messageMappingType?: MessageMappingType;

    constructor(data?: IMessageMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.messageMappingType = _data["messageMappingType"];
        }
    }

    static fromJS(data: any): MessageMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["messageMappingType"] = this.messageMappingType;
        return data;
    }
}

export interface IMessageMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
    messageMappingType?: MessageMappingType;
}

export class MessageMappingListDto implements IMessageMappingListDto {
    items?: MessageMappingDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IMessageMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageMappingDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MessageMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMessageMappingListDto {
    items?: MessageMappingDto[] | undefined;
    pagination?: PaginationResult;
}

export class MessageStaticMappingDto implements IMessageStaticMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
    message?: string | undefined;

    constructor(data?: IMessageStaticMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): MessageStaticMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageStaticMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["message"] = this.message;
        return data;
    }
}

export interface IMessageStaticMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
    message?: string | undefined;
}

export class MessageStaticMappingListDto implements IMessageStaticMappingListDto {
    items?: MessageStaticMappingDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IMessageStaticMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageStaticMappingDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MessageStaticMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageStaticMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMessageStaticMappingListDto {
    items?: MessageStaticMappingDto[] | undefined;
    pagination?: PaginationResult;
}

export class MessageWithMappingDto implements IMessageWithMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
    sourceTemplateMessageId?: string;
    sourceTemplateMessageName?: string | undefined;
    destinationTemplateMessageId?: string;
    destinationTemplateMessageName?: string | undefined;
    mappingItems?: PropertyMappingItem[] | undefined;
    dataMappings?: PropertyDataMappingItem[] | undefined;

    constructor(data?: IMessageWithMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.sourceTemplateMessageId = _data["sourceTemplateMessageId"];
            this.sourceTemplateMessageName = _data["sourceTemplateMessageName"];
            this.destinationTemplateMessageId = _data["destinationTemplateMessageId"];
            this.destinationTemplateMessageName = _data["destinationTemplateMessageName"];
            if (Array.isArray(_data["mappingItems"])) {
                this.mappingItems = [] as any;
                for (let item of _data["mappingItems"])
                    this.mappingItems!.push(PropertyMappingItem.fromJS(item));
            }
            if (Array.isArray(_data["dataMappings"])) {
                this.dataMappings = [] as any;
                for (let item of _data["dataMappings"])
                    this.dataMappings!.push(PropertyDataMappingItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MessageWithMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageWithMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sourceTemplateMessageId"] = this.sourceTemplateMessageId;
        data["sourceTemplateMessageName"] = this.sourceTemplateMessageName;
        data["destinationTemplateMessageId"] = this.destinationTemplateMessageId;
        data["destinationTemplateMessageName"] = this.destinationTemplateMessageName;
        if (Array.isArray(this.mappingItems)) {
            data["mappingItems"] = [];
            for (let item of this.mappingItems)
                data["mappingItems"].push(item.toJSON());
        }
        if (Array.isArray(this.dataMappings)) {
            data["dataMappings"] = [];
            for (let item of this.dataMappings)
                data["dataMappings"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMessageWithMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
    sourceTemplateMessageId?: string;
    sourceTemplateMessageName?: string | undefined;
    destinationTemplateMessageId?: string;
    destinationTemplateMessageName?: string | undefined;
    mappingItems?: PropertyMappingItem[] | undefined;
    dataMappings?: PropertyDataMappingItem[] | undefined;
}

export class MessageWithMappingListDto implements IMessageWithMappingListDto {
    items?: MessageWithMappingDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IMessageWithMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageWithMappingDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MessageWithMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageWithMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMessageWithMappingListDto {
    items?: MessageWithMappingDto[] | undefined;
    pagination?: PaginationResult;
}

export class MessageWithoutMappingDto implements IMessageWithoutMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;

    constructor(data?: IMessageWithoutMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): MessageWithoutMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageWithoutMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IMessageWithoutMappingDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    description?: string | undefined;
}

export class MessageWithoutMappingListDto implements IMessageWithoutMappingListDto {
    items?: MessageWithoutMappingDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IMessageWithoutMappingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MessageWithoutMappingDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MessageWithoutMappingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageWithoutMappingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMessageWithoutMappingListDto {
    items?: MessageWithoutMappingDto[] | undefined;
    pagination?: PaginationResult;
}

export class PropertyDataMappingItem implements IPropertyDataMappingItem {
    id?: string;
    createdAt?: Date;
    dataMappingId?: string;
    dataMappingName?: string | undefined;
    property?: string | undefined;
    dataMappingDirection?: DataMappingDirection;

    constructor(data?: IPropertyDataMappingItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.dataMappingId = _data["dataMappingId"];
            this.dataMappingName = _data["dataMappingName"];
            this.property = _data["property"];
            this.dataMappingDirection = _data["dataMappingDirection"];
        }
    }

    static fromJS(data: any): PropertyDataMappingItem {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDataMappingItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["dataMappingId"] = this.dataMappingId;
        data["dataMappingName"] = this.dataMappingName;
        data["property"] = this.property;
        data["dataMappingDirection"] = this.dataMappingDirection;
        return data;
    }
}

export interface IPropertyDataMappingItem {
    id?: string;
    createdAt?: Date;
    dataMappingId?: string;
    dataMappingName?: string | undefined;
    property?: string | undefined;
    dataMappingDirection?: DataMappingDirection;
}

export class TemplateMessageDto implements ITemplateMessageDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    integrationPointId?: string;
    integrationPointName?: string | undefined;
    json?: string | undefined;
    description?: string | undefined;

    constructor(data?: ITemplateMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.integrationPointId = _data["integrationPointId"];
            this.integrationPointName = _data["integrationPointName"];
            this.json = _data["json"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): TemplateMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["integrationPointId"] = this.integrationPointId;
        data["integrationPointName"] = this.integrationPointName;
        data["json"] = this.json;
        data["description"] = this.description;
        return data;
    }
}

export interface ITemplateMessageDto {
    id?: string;
    createdAt?: Date;
    name?: string | undefined;
    integrationPointId?: string;
    integrationPointName?: string | undefined;
    json?: string | undefined;
    description?: string | undefined;
}

export class TemplateMessageListDto implements ITemplateMessageListDto {
    items?: TemplateMessageDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: ITemplateMessageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateMessageDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TemplateMessageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateMessageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITemplateMessageListDto {
    items?: TemplateMessageDto[] | undefined;
    pagination?: PaginationResult;
}

export class WikiChannelPointChatItem implements IWikiChannelPointChatItem {
    id?: string;
    createdAt?: Date;
    text?: string | undefined;
    replyTo?: string | undefined;
    pathChannelMentions?: WikiPointPathChannelMention[] | undefined;

    constructor(data?: IWikiChannelPointChatItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.text = _data["text"];
            this.replyTo = _data["replyTo"];
            if (Array.isArray(_data["pathChannelMentions"])) {
                this.pathChannelMentions = [] as any;
                for (let item of _data["pathChannelMentions"])
                    this.pathChannelMentions!.push(WikiPointPathChannelMention.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WikiChannelPointChatItem {
        data = typeof data === 'object' ? data : {};
        let result = new WikiChannelPointChatItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["text"] = this.text;
        data["replyTo"] = this.replyTo;
        if (Array.isArray(this.pathChannelMentions)) {
            data["pathChannelMentions"] = [];
            for (let item of this.pathChannelMentions)
                data["pathChannelMentions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWikiChannelPointChatItem {
    id?: string;
    createdAt?: Date;
    text?: string | undefined;
    replyTo?: string | undefined;
    pathChannelMentions?: WikiPointPathChannelMention[] | undefined;
}

export class WikiChannelPointDto implements IWikiChannelPointDto {
    id?: string;
    createdAt?: Date;
    topic?: string | undefined;
    type?: WikiType;
    description?: string | undefined;
    tags?: string[] | undefined;
    channelId?: string | undefined;
    channelName?: string | undefined;
    chats?: WikiChannelPointChatItem[] | undefined;

    constructor(data?: IWikiChannelPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.topic = _data["topic"];
            this.type = _data["type"];
            this.description = _data["description"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.channelId = _data["channelId"];
            this.channelName = _data["channelName"];
            if (Array.isArray(_data["chats"])) {
                this.chats = [] as any;
                for (let item of _data["chats"])
                    this.chats!.push(WikiChannelPointChatItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WikiChannelPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new WikiChannelPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["topic"] = this.topic;
        data["type"] = this.type;
        data["description"] = this.description;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["channelId"] = this.channelId;
        data["channelName"] = this.channelName;
        if (Array.isArray(this.chats)) {
            data["chats"] = [];
            for (let item of this.chats)
                data["chats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWikiChannelPointDto {
    id?: string;
    createdAt?: Date;
    topic?: string | undefined;
    type?: WikiType;
    description?: string | undefined;
    tags?: string[] | undefined;
    channelId?: string | undefined;
    channelName?: string | undefined;
    chats?: WikiChannelPointChatItem[] | undefined;
}

export class WikiMessageMappingPointChatItem implements IWikiMessageMappingPointChatItem {
    id?: string;
    createdAt?: Date;
    text?: string | undefined;
    replyTo?: string | undefined;
    templateMessageMentions?: WikiPointTemplateMessageMention[] | undefined;
    propertyMappingMentions?: WikiPointPropertyMappingMention[] | undefined;

    constructor(data?: IWikiMessageMappingPointChatItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.text = _data["text"];
            this.replyTo = _data["replyTo"];
            if (Array.isArray(_data["templateMessageMentions"])) {
                this.templateMessageMentions = [] as any;
                for (let item of _data["templateMessageMentions"])
                    this.templateMessageMentions!.push(WikiPointTemplateMessageMention.fromJS(item));
            }
            if (Array.isArray(_data["propertyMappingMentions"])) {
                this.propertyMappingMentions = [] as any;
                for (let item of _data["propertyMappingMentions"])
                    this.propertyMappingMentions!.push(WikiPointPropertyMappingMention.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WikiMessageMappingPointChatItem {
        data = typeof data === 'object' ? data : {};
        let result = new WikiMessageMappingPointChatItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["text"] = this.text;
        data["replyTo"] = this.replyTo;
        if (Array.isArray(this.templateMessageMentions)) {
            data["templateMessageMentions"] = [];
            for (let item of this.templateMessageMentions)
                data["templateMessageMentions"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyMappingMentions)) {
            data["propertyMappingMentions"] = [];
            for (let item of this.propertyMappingMentions)
                data["propertyMappingMentions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWikiMessageMappingPointChatItem {
    id?: string;
    createdAt?: Date;
    text?: string | undefined;
    replyTo?: string | undefined;
    templateMessageMentions?: WikiPointTemplateMessageMention[] | undefined;
    propertyMappingMentions?: WikiPointPropertyMappingMention[] | undefined;
}

export class WikiMessageMappingPointDto implements IWikiMessageMappingPointDto {
    id?: string;
    createdAt?: Date;
    topic?: string | undefined;
    type?: WikiType;
    description?: string | undefined;
    tags?: string[] | undefined;
    messageMappingId?: string | undefined;
    messageMappingName?: string | undefined;
    chats?: WikiMessageMappingPointChatItem[] | undefined;

    constructor(data?: IWikiMessageMappingPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.topic = _data["topic"];
            this.type = _data["type"];
            this.description = _data["description"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.messageMappingId = _data["messageMappingId"];
            this.messageMappingName = _data["messageMappingName"];
            if (Array.isArray(_data["chats"])) {
                this.chats = [] as any;
                for (let item of _data["chats"])
                    this.chats!.push(WikiMessageMappingPointChatItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WikiMessageMappingPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new WikiMessageMappingPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["topic"] = this.topic;
        data["type"] = this.type;
        data["description"] = this.description;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["messageMappingId"] = this.messageMappingId;
        data["messageMappingName"] = this.messageMappingName;
        if (Array.isArray(this.chats)) {
            data["chats"] = [];
            for (let item of this.chats)
                data["chats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWikiMessageMappingPointDto {
    id?: string;
    createdAt?: Date;
    topic?: string | undefined;
    type?: WikiType;
    description?: string | undefined;
    tags?: string[] | undefined;
    messageMappingId?: string | undefined;
    messageMappingName?: string | undefined;
    chats?: WikiMessageMappingPointChatItem[] | undefined;
}

export class WikiPointDto implements IWikiPointDto {
    id?: string;
    createdAt?: Date;
    topic?: string | undefined;
    type?: WikiType;
    description?: string | undefined;
    tags?: string[] | undefined;

    constructor(data?: IWikiPointDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.topic = _data["topic"];
            this.type = _data["type"];
            this.description = _data["description"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): WikiPointDto {
        data = typeof data === 'object' ? data : {};
        let result = new WikiPointDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["topic"] = this.topic;
        data["type"] = this.type;
        data["description"] = this.description;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IWikiPointDto {
    id?: string;
    createdAt?: Date;
    topic?: string | undefined;
    type?: WikiType;
    description?: string | undefined;
    tags?: string[] | undefined;
}

export class WikiPointListDto implements IWikiPointListDto {
    items?: WikiPointDto[] | undefined;
    pagination?: PaginationResult;

    constructor(data?: IWikiPointListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WikiPointDto.fromJS(item));
            }
            this.pagination = _data["pagination"] ? PaginationResult.fromJS(_data["pagination"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WikiPointListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WikiPointListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagination"] = this.pagination ? this.pagination.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWikiPointListDto {
    items?: WikiPointDto[] | undefined;
    pagination?: PaginationResult;
}

export class ActionItem implements IActionItem {
    actionId?: string;
    actionName?: string | undefined;

    constructor(data?: IActionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionId = _data["actionId"];
            this.actionName = _data["actionName"];
        }
    }

    static fromJS(data: any): ActionItem {
        data = typeof data === 'object' ? data : {};
        let result = new ActionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionId"] = this.actionId;
        data["actionName"] = this.actionName;
        return data;
    }
}

export interface IActionItem {
    actionId?: string;
    actionName?: string | undefined;
}

export class ApiSpec implements IApiSpec {
    baseUrl?: string | undefined;
    path?: string | undefined;
    httpMethodType?: HttpMethodType;
    timeout?: number;
    query?: string | undefined;
    body?: string | undefined;
    authHttpType?: AuthHttpType;
    authHttpValue?: string | undefined;
    httpHeaders?: string | undefined;

    constructor(data?: IApiSpec) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"];
            this.path = _data["path"];
            this.httpMethodType = _data["httpMethodType"];
            this.timeout = _data["timeout"];
            this.query = _data["query"];
            this.body = _data["body"];
            this.authHttpType = _data["authHttpType"];
            this.authHttpValue = _data["authHttpValue"];
            this.httpHeaders = _data["httpHeaders"];
        }
    }

    static fromJS(data: any): ApiSpec {
        data = typeof data === 'object' ? data : {};
        let result = new ApiSpec();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["path"] = this.path;
        data["httpMethodType"] = this.httpMethodType;
        data["timeout"] = this.timeout;
        data["query"] = this.query;
        data["body"] = this.body;
        data["authHttpType"] = this.authHttpType;
        data["authHttpValue"] = this.authHttpValue;
        data["httpHeaders"] = this.httpHeaders;
        return data;
    }
}

export interface IApiSpec {
    baseUrl?: string | undefined;
    path?: string | undefined;
    httpMethodType?: HttpMethodType;
    timeout?: number;
    query?: string | undefined;
    body?: string | undefined;
    authHttpType?: AuthHttpType;
    authHttpValue?: string | undefined;
    httpHeaders?: string | undefined;
}

export enum AuthHttpType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum ChannelPathCompletedType {
    _1 = 1,
    _2 = 2,
}

export class ChannelPathMessage implements IChannelPathMessage {
    message?: string | undefined;
    httpStatusCode?: number | undefined;
    queryString?: string | undefined;

    constructor(data?: IChannelPathMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.httpStatusCode = _data["httpStatusCode"];
            this.queryString = _data["queryString"];
        }
    }

    static fromJS(data: any): ChannelPathMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ChannelPathMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["httpStatusCode"] = this.httpStatusCode;
        data["queryString"] = this.queryString;
        return data;
    }
}

export interface IChannelPathMessage {
    message?: string | undefined;
    httpStatusCode?: number | undefined;
    queryString?: string | undefined;
}

export enum ChannelPathType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum ConditionOperation {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export enum ConditionRelationshipType {
    _0 = 0,
    _1 = 1,
}

export enum ConditionResolverType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum DataMappingDirection {
    _0 = 0,
    _1 = 1,
}

export class DataMappingItem implements IDataMappingItem {
    sourceValue?: string | undefined;
    destinationValue?: string | undefined;

    constructor(data?: IDataMappingItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceValue = _data["sourceValue"];
            this.destinationValue = _data["destinationValue"];
        }
    }

    static fromJS(data: any): DataMappingItem {
        data = typeof data === 'object' ? data : {};
        let result = new DataMappingItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceValue"] = this.sourceValue;
        data["destinationValue"] = this.destinationValue;
        return data;
    }
}

export interface IDataMappingItem {
    sourceValue?: string | undefined;
    destinationValue?: string | undefined;
}

export enum HttpMethodType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class HttpStatusCode implements IHttpStatusCode {
    code?: number;
    name?: string | undefined;
    title?: string | undefined;

    constructor(data?: IHttpStatusCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): HttpStatusCode {
        data = typeof data === 'object' ? data : {};
        let result = new HttpStatusCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["title"] = this.title;
        return data;
    }
}

export interface IHttpStatusCode {
    code?: number;
    name?: string | undefined;
    title?: string | undefined;
}

export class HttpStatusCodeListDto implements IHttpStatusCodeListDto {
    items?: HttpStatusCode[] | undefined;

    constructor(data?: IHttpStatusCodeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(HttpStatusCode.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HttpStatusCodeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new HttpStatusCodeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHttpStatusCodeListDto {
    items?: HttpStatusCode[] | undefined;
}

export class HttpStatusRangeCode implements IHttpStatusRangeCode {
    from?: number;
    to?: number | undefined;

    constructor(data?: IHttpStatusRangeCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
        }
    }

    static fromJS(data: any): HttpStatusRangeCode {
        data = typeof data === 'object' ? data : {};
        let result = new HttpStatusRangeCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        return data;
    }
}

export interface IHttpStatusRangeCode {
    from?: number;
    to?: number | undefined;
}

export enum MessageMappingType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class PropertyExpectedValue implements IPropertyExpectedValue {
    value?: string | undefined;

    constructor(data?: IPropertyExpectedValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyExpectedValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyExpectedValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IPropertyExpectedValue {
    value?: string | undefined;
}

export class PropertyMappingItem implements IPropertyMappingItem {
    source?: string | undefined;
    destination?: string | undefined;

    constructor(data?: IPropertyMappingItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"];
            this.destination = _data["destination"];
        }
    }

    static fromJS(data: any): PropertyMappingItem {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyMappingItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source;
        data["destination"] = this.destination;
        return data;
    }
}

export interface IPropertyMappingItem {
    source?: string | undefined;
    destination?: string | undefined;
}

export class PropertyValueCondition implements IPropertyValueCondition {
    property?: string | undefined;
    value?: string | undefined;
    conditionOperator?: ConditionOperation;

    constructor(data?: IPropertyValueCondition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.property = _data["property"];
            this.value = _data["value"];
            this.conditionOperator = _data["conditionOperator"];
        }
    }

    static fromJS(data: any): PropertyValueCondition {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValueCondition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["property"] = this.property;
        data["value"] = this.value;
        data["conditionOperator"] = this.conditionOperator;
        return data;
    }
}

export interface IPropertyValueCondition {
    property?: string | undefined;
    value?: string | undefined;
    conditionOperator?: ConditionOperation;
}

export class WikiPointPathChannelMention implements IWikiPointPathChannelMention {
    pathId?: string;

    constructor(data?: IWikiPointPathChannelMention) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pathId = _data["pathId"];
        }
    }

    static fromJS(data: any): WikiPointPathChannelMention {
        data = typeof data === 'object' ? data : {};
        let result = new WikiPointPathChannelMention();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pathId"] = this.pathId;
        return data;
    }
}

export interface IWikiPointPathChannelMention {
    pathId?: string;
}

export class WikiPointPropertyMappingMention implements IWikiPointPropertyMappingMention {
    sourceProperty?: string | undefined;
    destinationProperty?: string | undefined;

    constructor(data?: IWikiPointPropertyMappingMention) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceProperty = _data["sourceProperty"];
            this.destinationProperty = _data["destinationProperty"];
        }
    }

    static fromJS(data: any): WikiPointPropertyMappingMention {
        data = typeof data === 'object' ? data : {};
        let result = new WikiPointPropertyMappingMention();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceProperty"] = this.sourceProperty;
        data["destinationProperty"] = this.destinationProperty;
        return data;
    }
}

export interface IWikiPointPropertyMappingMention {
    sourceProperty?: string | undefined;
    destinationProperty?: string | undefined;
}

export class WikiPointTemplateMessageMention implements IWikiPointTemplateMessageMention {
    templateMessageId?: string;
    property?: string | undefined;

    constructor(data?: IWikiPointTemplateMessageMention) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateMessageId = _data["templateMessageId"];
            this.property = _data["property"];
        }
    }

    static fromJS(data: any): WikiPointTemplateMessageMention {
        data = typeof data === 'object' ? data : {};
        let result = new WikiPointTemplateMessageMention();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateMessageId"] = this.templateMessageId;
        data["property"] = this.property;
        return data;
    }
}

export interface IWikiPointTemplateMessageMention {
    templateMessageId?: string;
    property?: string | undefined;
}

export enum WikiType {
    _0 = 0,
    _1 = 1,
}

export class CreatePermissionRoleCommand implements ICreatePermissionRoleCommand {
    commandId?: string;
    title?: string | undefined;

    constructor(data?: ICreatePermissionRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreatePermissionRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePermissionRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["title"] = this.title;
        return data;
    }
}

export interface ICreatePermissionRoleCommand {
    commandId?: string;
    title?: string | undefined;
}

export class DisabledPermissionRoleCommand implements IDisabledPermissionRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    disabled?: boolean;

    constructor(data?: IDisabledPermissionRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.permissionRoleId = _data["permissionRoleId"];
            this.disabled = _data["disabled"];
        }
    }

    static fromJS(data: any): DisabledPermissionRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DisabledPermissionRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["permissionRoleId"] = this.permissionRoleId;
        data["disabled"] = this.disabled;
        return data;
    }
}

export interface IDisabledPermissionRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    disabled?: boolean;
}

export class PermissionItem implements IPermissionItem {
    key?: string | undefined;
    title?: string | undefined;
    route?: string | undefined;
    parentKey?: string | undefined;

    constructor(data?: IPermissionItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.title = _data["title"];
            this.route = _data["route"];
            this.parentKey = _data["parentKey"];
        }
    }

    static fromJS(data: any): PermissionItem {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        data["route"] = this.route;
        data["parentKey"] = this.parentKey;
        return data;
    }
}

export interface IPermissionItem {
    key?: string | undefined;
    title?: string | undefined;
    route?: string | undefined;
    parentKey?: string | undefined;
}

export class PermissionKeysDto implements IPermissionKeysDto {
    permissionKeys?: string[] | undefined;

    constructor(data?: IPermissionKeysDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissionKeys"])) {
                this.permissionKeys = [] as any;
                for (let item of _data["permissionKeys"])
                    this.permissionKeys!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionKeysDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionKeysDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissionKeys)) {
            data["permissionKeys"] = [];
            for (let item of this.permissionKeys)
                data["permissionKeys"].push(item);
        }
        return data;
    }
}

export interface IPermissionKeysDto {
    permissionKeys?: string[] | undefined;
}

export class PermissionRoleDto implements IPermissionRoleDto {
    id?: string;
    title?: string | undefined;
    disabled?: boolean;
    users?: string[] | undefined;
    permissionUnits?: string[] | undefined;

    constructor(data?: IPermissionRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.disabled = _data["disabled"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
            if (Array.isArray(_data["permissionUnits"])) {
                this.permissionUnits = [] as any;
                for (let item of _data["permissionUnits"])
                    this.permissionUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): PermissionRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["disabled"] = this.disabled;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        if (Array.isArray(this.permissionUnits)) {
            data["permissionUnits"] = [];
            for (let item of this.permissionUnits)
                data["permissionUnits"].push(item);
        }
        return data;
    }
}

export interface IPermissionRoleDto {
    id?: string;
    title?: string | undefined;
    disabled?: boolean;
    users?: string[] | undefined;
    permissionUnits?: string[] | undefined;
}

export class PermissionRoleListDto implements IPermissionRoleListDto {
    items?: PermissionRoleDto[] | undefined;

    constructor(data?: IPermissionRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionRoleListDto {
    items?: PermissionRoleDto[] | undefined;
}

export class PermissionUnitDto implements IPermissionUnitDto {
    key?: string | undefined;
    title?: string | undefined;
    route?: string | undefined;
    parentKey?: string | undefined;

    constructor(data?: IPermissionUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.title = _data["title"];
            this.route = _data["route"];
            this.parentKey = _data["parentKey"];
        }
    }

    static fromJS(data: any): PermissionUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        data["route"] = this.route;
        data["parentKey"] = this.parentKey;
        return data;
    }
}

export interface IPermissionUnitDto {
    key?: string | undefined;
    title?: string | undefined;
    route?: string | undefined;
    parentKey?: string | undefined;
}

export class PermissionUnitListDto implements IPermissionUnitListDto {
    items?: PermissionUnitDto[] | undefined;

    constructor(data?: IPermissionUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPermissionUnitListDto {
    items?: PermissionUnitDto[] | undefined;
}

export class PermissionVersionDto implements IPermissionVersionDto {
    version?: string | undefined;

    constructor(data?: IPermissionVersionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): PermissionVersionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionVersionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        return data;
    }
}

export interface IPermissionVersionDto {
    version?: string | undefined;
}

export class SetPermissionsCommand implements ISetPermissionsCommand {
    commandId?: string;
    version?: string | undefined;
    permissions?: PermissionItem[] | undefined;

    constructor(data?: ISetPermissionsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.version = _data["version"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetPermissionsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetPermissionsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["version"] = this.version;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISetPermissionsCommand {
    commandId?: string;
    version?: string | undefined;
    permissions?: PermissionItem[] | undefined;
}

export class SetPermissionsToRoleCommand implements ISetPermissionsToRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    permissionUnits?: string[] | undefined;

    constructor(data?: ISetPermissionsToRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.permissionRoleId = _data["permissionRoleId"];
            if (Array.isArray(_data["permissionUnits"])) {
                this.permissionUnits = [] as any;
                for (let item of _data["permissionUnits"])
                    this.permissionUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): SetPermissionsToRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetPermissionsToRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["permissionRoleId"] = this.permissionRoleId;
        if (Array.isArray(this.permissionUnits)) {
            data["permissionUnits"] = [];
            for (let item of this.permissionUnits)
                data["permissionUnits"].push(item);
        }
        return data;
    }
}

export interface ISetPermissionsToRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    permissionUnits?: string[] | undefined;
}

export class SetUsersToRoleCommand implements ISetUsersToRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    users?: string[] | undefined;

    constructor(data?: ISetUsersToRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.permissionRoleId = _data["permissionRoleId"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(item);
            }
        }
    }

    static fromJS(data: any): SetUsersToRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetUsersToRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["permissionRoleId"] = this.permissionRoleId;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item);
        }
        return data;
    }
}

export interface ISetUsersToRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    users?: string[] | undefined;
}

export class UpdatePermissionRoleCommand implements IUpdatePermissionRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    title?: string | undefined;

    constructor(data?: IUpdatePermissionRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commandId = _data["commandId"];
            this.permissionRoleId = _data["permissionRoleId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdatePermissionRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePermissionRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commandId"] = this.commandId;
        data["permissionRoleId"] = this.permissionRoleId;
        data["title"] = this.title;
        return data;
    }
}

export interface IUpdatePermissionRoleCommand {
    commandId?: string;
    permissionRoleId?: string;
    title?: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}